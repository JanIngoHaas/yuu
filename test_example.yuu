// Complex test file demonstrating advanced Yuu language features
// This combines multiple language constructs for thorough CLI testing

struct Vector3D {
    x: f32,
    y: f32,  
    z: f32,
}

struct Matrix {
    rows: i64,
    cols: i64,
    data: f32,
}

fn vector_length(v: Vector3D) -> f32 => break (v.x * v.x + v.y * v.y + v.z * v.z).sqrt() .

fn sqrt(value: f32) -> f32 =>
    // Simplified sqrt approximation
    let mut guess = value / 2.0;
    let mut i = 0;
    while i < 5 =>
        guess = (guess + value / guess) / 2.0;
        i = i + 1 .
    break guess .

fn vector_normalize(v: Vector3D) -> Vector3D =>
    let len = v.vector_length();
    break Vector3D {
        x: v.x / len,
        y: v.y / len, 
        z: v.z / len,
    } .

fn vector_scale(v: Vector3D, factor: f32) -> Vector3D =>
    break Vector3D {
        x: v.x * factor,
        y: v.y * factor,
        z: v.z * factor,
    } .

fn vector_dot(a: Vector3D, b: Vector3D) -> f32 => break a.x * b.x + a.y * b.y + a.z * b.z .

fn fibonacci(n: i64) -> i64 =>
    break
    if n <= 1 => break n .
    else => break fibonacci(n - 1) + fibonacci(n - 2) . .

fn factorial_iterative(n: i64) -> i64 =>
    let mut result = 1;
    let mut i = 1;
    while i <= n =>
        result = result * i;
        i = i + 1 .
    break result .

fn complex_calculation(input: Vector3D, iterations: i64) -> Vector3D =>
    let mut current = input;
    let mut counter = 0;
    
    let processed = :processing_loop =>
        while counter < iterations =>
            let normalized = current.vector_normalize();
            let scaled = normalized.vector_scale(2.0);
            
            if scaled.vector_length() > 10.0 =>
                break :processing_loop scaled .
            
            current = Vector3D {
                x: scaled.x + 1.0,
                y: scaled.y - 0.5,
                z: scaled.z * 1.1,
            };
            
            counter = counter + 1 .
        break current . ;
    break processed .

fn matrix_multiply_scalar(m: Matrix, scalar: f32) -> Matrix =>
    break Matrix {
        rows: m.rows,
        cols: m.cols,
        data: m.data * scalar,
    } .

fn test_unified_call_chains() -> f32 =>
    let v1 = Vector3D { x: 1.0, y: 2.0, z: 3.0 };
    let v2 = Vector3D { x: 4.0, y: 5.0, z: 6.0 };
    
    // Complex chained unified call syntax
    let result = v1.vector_normalize().vector_scale(3.0);
    let dot_product = vector_dot(result, v2);
    
    break dot_product .

fn main() -> i64 =>
    // Test various features
    let vec = Vector3D { x: 3.0, y: 4.0, z: 5.0 };
    let processed = complex_calculation(vec, 5);
    
    let fib_result = fibonacci(8);
    let fact_result = factorial_iterative(5);
    
    let matrix = Matrix { rows: 3, cols: 3, data: 2.5 };
    let scaled_matrix = matrix_multiply_scalar(matrix, 2.0);
    
    let chain_result = test_unified_call_chains();
    
    // Return some computed value
    break fib_result + fact_result .